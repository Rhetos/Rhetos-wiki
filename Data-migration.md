When a developer makes changes in the business application that affect the tables and columns
in the database (renaming an entity, for example), there is often a need to migrate the data
from the old data structure to the new one.

This article describes how to develop and deploy data migration scripts that are used
to migrate the data when upgrading your Rhetos application.

Table of contents:

1. [Developing data-migration scripts](#developing-data-migration-scripts)
   1. [SQL scripts](#sql-scripts)
   2. [Formatting](#formatting)
   3. [Rules for writing data-migration scripts](#rules-for-writing-data-migration-scripts)
   4. [Modifying an existing data-migration script](#modifying-an-existing-data-migration-script)
2. [Examples](#examples)
   1. [Renaming a property](#renaming-a-property)
   2. [Moving a property from one entity to another](#moving-a-property-from-one-entity-to-another)
   3. [Initializing a new unique property value](#initializing-a-new-unique-property-value)
   4. [Changing a property's type](#changing-a-propertys-type)
3. [Advanced Topics](#advanced-topics)
   1. [Deploying migration scripts](#deploying-migration-scripts)
   2. [Automatic use of the migration tables when dropping and creating columns](#automatic-use-of-the-migration-tables-when-dropping-and-creating-columns)
   3. [Database structure independence](#database-structure-independence)
   4. [Cleanup](#cleanup)
   5. [Database constraint blocking the data migration](#database-constraint-blocking-the-data-migration)
   6. [Downgrade scripts to revert changes in database](#downgrade-scripts-to-revert-changes-in-database)

## Developing data-migration scripts

Compared to *Entity Framework migrations*, in Rhetos migrations developers only need to
manage **migration of data**. Changes to database structure (tables, columns and other objects)
are managed by Rhetos framework internally. Developers might use data-migration scripts to modify
the database structure only in rare cases in order to optimize standard Rhetos framework upgrade process.

### SQL scripts

Data-migration scripts are regular SQL scripts, with the code following specific rules as describes in this article.
The scripts are placed in a DataMigration subfolder in the Rhetos app project or a Rhetos plugin package.
When deploying the Rhetos app, the scripts will be executed in the alphabetical order
(by folder name, than file name), skipping the scripts that were already executed in previous deployments.

The recommended naming convention:

* The data-migration scripts inside DataMigration folder should be grouped in subfolders by the application's release version.
* Each script in the subfolder should have numbered prefix (starting with "1 " or "001 "),
  to ensure the correct order when executing the scripts.

For example:

```text
DataMigration\1.0\1 - Insert master.sql
DataMigration\1.0\2 - Insert detail.sql
DataMigration\2.0\1 - Update detail codes.sql
```

### Formatting

A data-migration script must be written in a specific format, see the example below.
It is recommended to execute the stored procedure `Rhetos.HelpDataMigration` to
**generate a new data-migration script**, then write the specific SQL code in it.

In the following example, the developer is changing a property name on the entity `Bookstore.Book`
(edits the .rhe script), and also needs to write a data-migration SQL script that copies the data
from the old column (`Name`) to the new column (`Title`) in the table `Bookstore.Book`.

The data migration script looks like this:

```sql
/*DATAMIGRATION B891788E-0BE1-4858-86E9-F47884330F0A*/

-- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Bookstore', 'Book';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Book', 'ID', 'uniqueidentifier';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Book', 'Name', 'nvarchar(256)';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Book', 'Title', 'nvarchar(256)';
GO

UPDATE
    _Bookstore.Book
SET
    Title = Name
WHERE
    Title IS NULL;

EXEC Rhetos.DataMigrationApplyMultiple 'Bookstore', 'Book', 'ID, Title';
```

### Rules for writing data-migration scripts

1. Each script must have a unique tag at the beginning (GUID is recommended).
   Based on that tag, Rhetos monitors which scripts have already been executed.
2. The script may only read and write data from the migration tables (e.g. \_Bookstore.Book); it should never directly access the original tables.
   The migration tables are created by `DataMigrationUse` procedure, executed at the beginning of the script.
   They have the same name as the original tables, but are placed in the database schema with "`_`" prefix (underscore).
3. The `DataMigrationUse` procedure will:
    * Create a migration table with the selected columns.
    * Copy the data from the original table.
    * If the column already exists, but has a different data type, it will convert the migrated data type if the
      implicit conversion is supported by the SQL Server (see ALTER TABLE ALTER COLUMN).
4. The `DataMigrationApplyMultiple` procedure will:
    * Copy the data from the migration table to the original table.
    * If there were inserted or deleted records in the migration table, the procedure will also insert/delete the records in the original table.
    * If the original table does not exist yet (will be created in the next version), the procedure will not
      try to copy the data. The data will be copied automatically by Rhetos when the original table is created.

These rules allow the script to be executed **independently of the current database structure**,
so that a script can be executed either before or after a specific version is deployed, with the same results.
This allows Rhetos to execute the scripts in different situations:

1. when upgrading an existing application/database to a new version
2. when deploying the application for the first time to an empty database
3. after the new version has already been deployed to a development environment (when developing the migration script)

Note that after generating the data-migration script by executing `Rhetos.HelpDataMigration`,
you might need to **manually adjust** the *DataMigrationUse* and *DataMigrationApplyMultiple* parts of this script:

* You might need to add new lines to the script with *DataMigrationUse*,
  if some columns do not currently exist in your database (not yet deployed),
  but you need to use them the script.
  Make sure to specify the correct [column type](Data-structure-properties).
* You may remove *DataMigrationUse* for columns that are not needed in this script. Keep the ID column.
* You may remove columns from *DataMigrationApplyMultiple* if not modifying the data in those columns. Keep the ID column.

Data migration scripts should be written in such way that allows a script to be executed
**multiple times** without negative consequences.
For example, before inserting a record, it should check if the record already exists.
This principle simplifies more advanced scenarios such as automatic downgrades and upgrades,
or error recovery on dbupdate.

### Modifying an existing data-migration script

How Rhetos detects changes in an older data-migration script:

* On deployment (dbupdate), Rhetos checks the tag from the script's header (GUID) to verify if the script
  has already been executed on the current database.
* The tags from the previously executed scripts are stores in the database.
  If the script has a new tag (or modified), the script will be executed on deployment.
* This also allows developers to later rename or reorganize the old data-migration scripts without
  executing them again, if they don't change the tag.

When modifying an existing data-migration script, always consider if the **old version** of the script
has already been executed on your database, other developers' databases, test environments
or a production environment.

* For example, if the old script inserted some incorrect data, then the new version of the script might
  leave the old incorrect data on databases where the old script has already been executed.

As a rule of thumb, it best to **always add a new script that corrects the data, instead of modifying the existing one**.

* This way, you can be sure that the result will be the same on all environments,
  whether the old script has been executed previously or not.

There are cases when you need to modify the existing script. For example if the old script has a
bug that deletes some data from the database, then adding a new script cannot correct the lost data.
When modifying an existing script, make sure to **change the GUID code** in the script header if
you want it to execute again on a database where it has already been executed.

## Examples

### Renaming a property

Example task:

* There in an entity `Book` in the module `Bookstore`, with a ShortString property `Name`.
* In the new version of the application, the property `Name` is renamed to `Title`.
* Write a data-migration scripts that migrates the data from the old column `Name` to the new column `Title`.

Note that the Rhetos will not detect that the property is renamed.
It always interprets this kind of modification as "remove the old property Name" and "create a new property Title".

Solution:

After renaming the property in the DSL script, a new data-migration .sql script must be created
in the DataMigration folder, with the following content:

```sql
/*DATAMIGRATION B891788E-0BE1-4858-86E9-F47884330F0A*/

-- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Bookstore', 'Book';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Book', 'ID', 'uniqueidentifier';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Book', 'Name', 'nvarchar(256)';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Book', 'Title', 'nvarchar(256)';
GO

UPDATE
    _Bookstore.Book
SET
    Title = Name
WHERE
    Title IS NULL;

EXEC Rhetos.DataMigrationApplyMultiple 'Bookstore', 'Book', 'ID, Title';
```

How to write this script:

1. Prepare test data:
   1. For this example, your application should contain `Module Bookstore { Entity Book { ShortString Name; } }`.
      Build your application to update the database, so that the table Bookstore.Book is created in the database.
      Enter some test data into the table, directly in the database.
   2. In DSL script, modify the property name from `Name` to `Title`, and update the database again.
2. In SQL Server Management Studio, execute `EXEC Rhetos.HelpDataMigration 'Bookstore', 'Book'` on your database to generate
   the overall script structure similar to the one above.
3. You will need to manually write a new line with *DataMigrationUse* for column `Name` or `Title`,
   depending on whether you executed *HelpDataMigration* before or after
   deploying the modified property name to the database.
4. Also make sure that the *DataMigrationApplyMultiple* contains the column `Title`, and not `Name`,
   because this is the new value that needs to be applied to the original table.
5. After the script header and footer are correct, write the `UPDATE` statement.

You can test this script in SSMS by adding `BEGIN TRAN` at the beginning and `SELECT * FROM _Bookstore.Book; ROLLBACK;` at the end.

When tested, the migration script should be added to DataMigration folder in your application,
so that Rhetos can automatically deploy it.

### Moving a property from one entity to another

Example task:

* There are entities `E1` and `E2` in the module `Demo`.
  `E2` extends `E1`, so they have the same ID values.
* In the old version of the application, the entity `E1` has the property `P`.
* We have developed a new version, where the property `P` is moved from the entity `E1` and to `E2`.
* We need to migrate the data from `E1` to `E2`.

Solution:

```sql
/*DATAMIGRATION 3CCB28D7-F257-4EDE-9A8E-6B9A7991241B*/

-- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Demo', 'E1';
EXEC Rhetos.DataMigrationUse 'Demo', 'E1', 'ID', 'uniqueidentifier';
EXEC Rhetos.DataMigrationUse 'Demo', 'E1', 'P', 'nvarchar(256)';
-- The following lines were generated by: EXEC Rhetos.HelpDataMigration 'Demo', 'E2';
EXEC Rhetos.DataMigrationUse 'Demo', 'E2', 'ID', 'uniqueidentifier';
EXEC Rhetos.DataMigrationUse 'Demo', 'E2', 'P', 'nvarchar(256)';
GO

-- Don't forget to use the underscore '_' in the schema name.
UPDATE
    e2
SET
    P = e1.P
FROM
    _Demo.E2 e2
    INNER JOIN _Demo.E1 e1 ON e1.ID = e2.ID
WHERE
    e2.P IS NULL; -- Safeguard if script is executed multiple times.

EXEC Rhetos.DataMigrationApplyMultiple 'Demo', 'E2', 'ID, P';
```

How to write this script:

1. Usually you will first execute *HelpDataMigration* for both entities E1 and E2,
   to generate the overall script structure and the *DataMigrationUse* property preparation lines.
   Combine the results into a single data-migration script as shown above.
2. You will need to manually write a new line with *DataMigrationUse* for
   column 'P' on entity 'E1' or 'E2', depending on whether you executed
   *HelpDataMigration* before or after deploying the modifications to the database.
3. Keep only the *DataMigrationApplyMultiple* for E2, because this script does not modify the data in E1.
   Make sure this line contains the new column `P` as shown above.
4. After the script header and footer are correct, write the `UPDATE` statement.

You can test this script in SSMS by adding `BEGIN TRAN` at the beginning and `SELECT * FROM _Demo.E2; ROLLBACK;` at the end.

### Initializing a new unique property value

Data initialization is obligatory if the new property is unique,
to avoid the unique constraint database error for multiple null values
if any records might exist in the table.

The following script initializes the new column "Code" with the generated numeric codes.
This is an example from the [Bookstore](https://github.com/Rhetos/Bookstore) demo application.

```sql
/*DATAMIGRATION DC31DB21-8E87-49F9-A334-E7EB246DBD53*/

-- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Bookstore', 'Topic';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Topic', 'ID', 'uniqueidentifier';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Topic', 'Code', 'nvarchar(256)';
EXEC Rhetos.DataMigrationUse 'Bookstore', 'Topic', 'Name', 'nvarchar(256)';
GO

SELECT
    t.ID,
    NewCode = CAST(ROW_NUMBER() OVER (ORDER BY t.Name, t.ID) AS NVARCHAR(10))
INTO
    #codes
FROM
    _Bookstore.Topic t
WHERE
    t.Code IS NULL; -- Make sure to ignore already initialized values, if this script is executed multiple times.

UPDATE
    t
SET
    Code = c.NewCode
FROM
    _Bookstore.Topic t
    INNER JOIN #codes c ON c.ID = t.ID

EXEC Rhetos.DataMigrationApplyMultiple 'Bookstore', 'Topic', 'ID, Code';
```

### Changing a property's type

If a property's type is changed, deployment of the new version will do the following:

* First, the old column will be removed from the table, automatically keeping the backup in the migration table.
* New property will be created and the data will be restored from the migration table.
* When restoring the data, SQL Server will try to automatically convert the data type.
* If SQL Server does not support implicit conversion of the these type, the developer should create
  a data-migration script that modifies the data or the column type in the migration table.

## Advanced Topics

### Deploying migration scripts

When Rhetos updates the application's database (*rhetos.exe dbupdate* or *DeployPackages.exe*),
it will automatically execute the data-migration scripts:

* It executes the data-migration scripts *before* modifying the database structure (tables and columns, e.g.).
* If the database update fails, it will execute those data-migration scripts
  *again* on next deployment. This means that the migration scripts should be written in such way that allows a script
  to be executed *multiple* times without negative consequences.
* If a Rhetos package depends on another package (dependencies are defined in .nuspec),
  migration scripts from the other package will be executed first.
* DateMigration scripts within a package are executed ordered by folder name,
  then by file name. [Natural sort](https://en.wikipedia.org/wiki/Natural_sort_order) is used to order the scripts.
* The previously executed scripts are logged in `Rhetos.DataMigrationScript` table.
* Rhetos will check the tag from the script's header to verify if the script is already executed.
  This allows developers to later reorganize and rename the old data-migration scripts without executing them again.

### Automatic use of the migration tables when dropping and creating columns

* If a property, an entity or a module is removed in a new version of the application being deployed,
  Rhetos will keep a backup of its data in the migration tables.
* If the property/entity/module is brought back later, Rhetos will automatically restore the data
  from the corresponding data migration table.
* During deployment, Rhetos keeps track of the data that is copied from
  the original tables to the migration tables.
  If multiple migration scripts execute the `Rhetos.DataMigrationUse` procedure for a same table,
  the data will be copied only on a first call.
  This ensures that later script will not overwrite data modification of a previous script.

### Database structure independence

The data migration scripts are independent of the current database structure,
so the developers don't need to couple the database structure versioning with the data migration scripts.

In the following examples, the same data-migration script is executed in different database versions
(before or after upgrading the database), resulting with the identical data at the end.
The steps that follow the main data flow are marked bold.

The examples show the effect of a data-migration script that copies the data from entity A to B,
when the entity in module "M" is renamed from "A" to "B".

Option A) Deployment before the data migration:

1. Rhetos dbupdate - Updating database structure
    1. **Drop M.A: backup to _M.A**
    2. Create M.B
2. Manual execution of the data-migration script
    1. DataMigrationUse M.A: M.A => _M.A (nothing to do, A does not exits, _A already contains old data)
    2. DataMigrationUse M.B: M.B => _M.B (B is empty)
    3. **SQL update query: _M.A => _M.B**
    4. **DataMigrationApply M.B: _M.B => M.B**

Option B) Data migration before the deployment:

1. Rhetos dbupdate - Data migration
    1. **DataMigrationUse M.A: M.A => _M.A**
    2. DataMigrationUse M.B: M.B => _M.B (nothing to do, B does not exist)
    3. **Update: _M.A => _M.B**
    4. DataMigrationApply M.B: _M.B => M.B (nothing to do, B does not exist)
2. Rhetos dbupdate - Updating database structure
    1. Drop M.A
    2. **Create M.B: restore from _B**

### Cleanup

* After upgrading the database, Rhetos will delete the migration columns and tables
  that are copied to the original tables.
* The migration table and columns that don't exist in the new version of the application will be kept indefinitely as a backup.
* You can optionally delete the backup tables (everything in database schemas that start with an underscore "_").
  This is *not recommended* if the last deployment failed, because it could result with a data loss.
  Delete the old migration tables only if they contain a considerable amount of data and
  you need to reduce the database size.

### Database constraint blocking the data migration

This example describes a special case when an **existing database constraint**
(a unique index, for example) prevents the execution of a standard data-migration script.
In this case, a possible workaround is to *cleanly* remove the constraint before
modifying the data.

Example scenario:

1. Entity `Status` has a unique constraint on the `Name` property. This version of the application
   has already been deployed, and the database contains a UNIQUE INDEX on column Name.

    ```c
    Entity Status
    {
        ShortString Code { Unique; Required; }
        ShortString Name { Unique; Required; }
    }
    ```

2. We want to *remove* the Unique constraint on `Name`, and write a data-migration script that inserts
   two records with the same name:

    ```text
    Code = '001', Name = 'Status A'
    Code = '002', Name = 'Status A'
    ```

3. When we run Rhetos dbupdate, the data-migration scripts are executed *before* upgrading the database structure
   (i.e. before this unique index is dropped). This is why the data-migration script
   will result with the database error: `Cannot insert duplicate key row ...` when the new data
   is copied to the `Status` table (this error will occur at the line with DataMigrationApplyMultiple).

A possible workaround is to drop the unique index directly in the data-migration script,
before applying the data modifications to your table (before DataMigrationApplyMultiple).
To do it safely, you will need to **update Rhetos metadata** in table `AppliedConcept`,
to avoid any issues with future deployments.

Here is example of the modified data-migration script.
The only difference from a standard script is the added block of code that
handles `AppliedConcept` and `IX_Status_Name`.

```sql
/*DATAMIGRATION BC9C8DC3-CA64-47FF-8360-C0DEB41A9717*/

-- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Demo', 'Status';
EXEC Rhetos.DataMigrationUse 'Demo', 'Status', 'ID', 'uniqueidentifier';
EXEC Rhetos.DataMigrationUse 'Demo', 'Status', 'Code', 'nvarchar(256)';
EXEC Rhetos.DataMigrationUse 'Demo', 'Status', 'Name', 'nvarchar(256)';
GO

IF NOT EXISTS (SELECT * FROM _Demo.Status)
BEGIN
    INSERT INTO _Demo.Status (ID, Code, Name) SELECT NEWID(), '001', 'Status A';
    INSERT INTO _Demo.Status (ID, Code, Name) SELECT NEWID(), '002', 'Status A';
END

-- The following part is required before DataMigrationApplyMultiple to avoid the unique constraint error:
-- "Cannot insert duplicate key row in object 'Demo.Status' with unique index 'IX_Status_Name'. The duplicate key value is (Status A)."
IF EXISTS (SELECT * FROM Rhetos.AppliedConcept WHERE CreateQuery LIKE 'CREATE%INDEX% IX_Status_Name %')
BEGIN
    DROP INDEX IX_Status_Name ON Demo.Status;

    -- Updating Rhetos database metadata, so the framework knows that the index is cleanly removed.
    DELETE FROM Rhetos.AppliedConceptDependsOn WHERE DependentID =
        (SELECT ID FROM Rhetos.AppliedConcept WHERE CreateQuery LIKE 'CREATE%INDEX% IX_Status_Name %');
    DELETE FROM Rhetos.AppliedConceptDependsOn WHERE DependsOnID =
        (SELECT ID FROM Rhetos.AppliedConcept WHERE CreateQuery LIKE 'CREATE%INDEX% IX_Status_Name %');
    DELETE FROM Rhetos.AppliedConcept WHERE CreateQuery LIKE 'CREATE%INDEX% IX_Status_Name %';
END

EXEC Rhetos.DataMigrationApplyMultiple 'Demo', 'Status', 'ID, Code, Name';
```

Modifying the database objects in data-migration scripts can be risky
if you are not fully aware of the context, so it should only be used in rare cases
when there is no better workaround available.

### Downgrade scripts to revert changes in database

Custom downgrade data-migration scripts are supported since Rhetos v4.3.

The data migration in Rhetos allows custom SQL scripts to be executed when "downgrading" database
to an older version of the application.

* Note that in production environment the downgrade is relatively rare event, but in development
  and test environments it can be a common occurrence, for example when switching between different
  development branches in source repository in a single development environment.
* Downgrade is automatically handled by Rhetos and in most cases there is no need to
  write custom data-migration scripts for downgrade. **The internal usage of migration schemas to
  backup and restore columns in database often removes the need for any manual downgrade scripts.**
  For example, if a column is renamed and a custom data-migration script copies data to a new column,
  downgrade to an older version will automatically restore old column's data from the migration schema,
  see [Automatic use of the migration tables when dropping and creating columns](#automatic-use-of-the-migration-tables-when-dropping-and-creating-columns).
* The downgrade scripts are useful only in rare cases when deployment of an older version of
  the application could cause issues with the data, or a specific optimization is implemented
  to speed up both upgrade and downgrade database changes.

**Downgrade script** is similar to standard data-migration script, with the following changes:

1. Downgrade script should be placed next to the related upgrade script (standard data-migration script),
   and have the same file name with added ".down" suffix. See the example below.
2. The script header (first line) should contain label "DATAMIGRATION-DOWN" instead of "DATAMIGRATION".
3. The script header should have se same tag (identifier) as the related upgrade script.

For example, consider the following case:

> In a new version of the application all usernames must start with a prefix `domain\`,
> while the older version supports only usernames without the prefix.

Solution can be to write a data-migration script that adds the required prefix to the existing
usernames in database, and additionally a *downgrade* data-migration script to remove the prefix,
to simplify developer's work when switching between different development branches on a development
or test environment. The following two files are added to the projects DataMigration folder.

1. A standard data-migration script, named `Principal domain prefix.sql`:

    ```sql
    /*DATAMIGRATION 94B24CF5-F5CC-4609-8137-1618F967A7B5*/

    -- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Common', 'Principal';
    EXEC Rhetos.DataMigrationUse 'Common', 'Principal', 'ID', 'uniqueidentifier';
    EXEC Rhetos.DataMigrationUse 'Common', 'Principal', 'Name', 'nvarchar(256)';
    GO

    UPDATE _Common.Principal
    SET Name = 'domain\' + Name
    WHERE LEFT(Name, 7) <> 'domain\'

    EXEC Rhetos.DataMigrationApplyMultiple 'Common', 'Principal', 'ID, Name';
    ```

2. The downgrade script `Principal domain prefix.down.sql`:

    ```sql
    /*DATAMIGRATION-DOWN 94B24CF5-F5CC-4609-8137-1618F967A7B5*/

    -- The following lines are generated by: EXEC Rhetos.HelpDataMigration 'Common', 'Principal';
    EXEC Rhetos.DataMigrationUse 'Common', 'Principal', 'ID', 'uniqueidentifier';
    EXEC Rhetos.DataMigrationUse 'Common', 'Principal', 'Name', 'nvarchar(256)';
    GO

    UPDATE _Common.Principal
    SET Name = SUBSTRING(Name, 8, 256)
    WHERE LEFT(Name, 7) = 'domain\'

    EXEC Rhetos.DataMigrationApplyMultiple 'Common', 'Principal', 'ID, Name';
    ```

   Note that headers of 'up' and 'down' scripts must have the matching tag (GUID),
   but the down script has "DATAMIGRATION-DOWN" header label.
   Naming convention is enforced to keep the 'up' and 'down' scripts together:
   The 'down' script must match the 'up' script name with suffix ".down".
